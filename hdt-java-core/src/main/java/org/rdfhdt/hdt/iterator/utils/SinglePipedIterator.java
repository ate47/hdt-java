package org.rdfhdt.hdt.iterator.utils;

import java.util.Iterator;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * a utility class to create an iterator from the value returned by another Thread
 *
 * @param <T> the iterator type
 * @author Antoine Willerval
 */

public class SinglePipedIterator<T> implements Iterator<T> {

	/**
	 * RuntimeException generated by the PipedIterator
	 * @author Antoine Willerval
	 */
	public static class PipedIteratorException extends RuntimeException {
		public PipedIteratorException(String message, Throwable t) {
			super(message, t);
		}
	}

	/**
	 * Callback for the {@link #createOfCallback(org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipeCallBack)} method
	 *
	 * @param <T> the iterator type
	 * @author Antoine Willerval
	 */
	@FunctionalInterface
	public interface PipeCallBack<T> {
		/**
		 * method called from the new thread to generate the new data, at the end of the callback, the pipe is closed
		 * with or without exception
		 *
		 * @param pipe the pipe to fill
		 * @throws Exception any exception returned by the generator
		 */
		void createPipe(SinglePipedIterator<T> pipe) throws Exception;
	}

	/**
	 * create a piped iterator from a callback runner, the call to the callback should be made in the callbackRunner
	 *
	 * @param callbackRunner the callback runner
	 * @param <T>            type of the iterator
	 * @return the iterator
	 */
	public static <T> SinglePipedIterator<T> createOfCallback(PipeCallBack<T> callbackRunner) {
		SinglePipedIterator<T> pipe = new SinglePipedIterator<>();

		Thread thread = new Thread(() -> {
			try {
				callbackRunner.createPipe(pipe);
				pipe.closePipe();
			} catch (Throwable e) {
				pipe.closePipe(e);
			}
		}, "PipeIterator");
		thread.start();

		return pipe;
	}

	private class PipedNode {
		Supplier<T> t;

		public PipedNode(Supplier<T> t) {
			this.t = t;
		}

		boolean isDataNode() {
			return true;
		}
	}

	private class PipedNodeEnd extends PipedNode {
		private final Throwable exception;

		public PipedNodeEnd(Throwable exception) {
			super(null);
			this.exception = exception;
		}

		boolean isDataNode() {
			if (exception != null) {
				throw new PipedIteratorException("Crash while creating pipe", exception);
			}
			return false;
		}
	}

	private final Object SYNC = new Object() {
	};
	private PipedNode future;
	private boolean read = true;
	private PipedNode next;

	/**
	 * add an element to the piped iterator
	 *
	 * @param element the element to pipe
	 * @throws org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipedIteratorException in case of Interruption
	 */
	public void addElement(Supplier<T> element) throws PipedIteratorException {
		try {
			synchronized (SYNC) {
				read = false;
				SYNC.notifyAll();
				while (!read) {
					SYNC.wait();
				}
				future = new PipedNode(element);
				SYNC.notifyAll();
				while (future != null) {
					SYNC.wait();
				}
			}
		} catch (InterruptedException e) {
			throw new PipedIteratorException("Can't add element", e);
		}
	}

	/**
	 * close the pipe after the last added element
	 *
	 * @throws org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipedIteratorException in case of Interruption
	 */
	public void closePipe() throws PipedIteratorException {
		closePipe(null);
	}

	/**
	 * close the pipe after the last added element
	 *
	 * @param e exception to call at the {@link #hasNext()} next call
	 * @throws org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipedIteratorException in case of Interruption
	 */
	public void closePipe(Throwable e) throws PipedIteratorException {
		synchronized (SYNC) {
			future = new PipedNodeEnd(e);
			read = false;
			SYNC.notifyAll();
		}
	}

	/**
	 * @return if the iterator has a next element, or block until it found it or the pipe is closed
	 * @throws org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipedIteratorException if the pipe got an error while closing or in case of Interruption
	 */
	@Override
	public boolean hasNext() throws PipedIteratorException {
		if (next == null) {
			try {
				synchronized (SYNC) {
					while (read) {
						SYNC.wait();
					}
					read = true;
					SYNC.notifyAll();
					while (future == null) {
						SYNC.wait();
					}
					next = future;
					if (next.isDataNode()) {
						// don't remove the end node
						future = null;
						SYNC.notifyAll();
						return true;
					}
					return false;
				}
			} catch (InterruptedException e) {
				throw new PipedIteratorException("Can't get next element", e);
			}
		}
		return next.isDataNode();
	}

	/**
	 * map this iterator to another type
	 * @param mappingFunction the mapping function
	 * @param <E> the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> map(Function<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}
	/**
	 * map this iterator to another type
	 * @param mappingFunction the mapping function
	 * @param <E> the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> mapWithId(MapIterator.MapWithIdFunction<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}

	/**
	 * @return the next iterator element
	 * @throws org.rdfhdt.hdt.iterator.utils.SinglePipedIterator.PipedIteratorException if the pipe got an error while closing or in case of Interruption
	 */
	@Override
	public T next() throws PipedIteratorException {
		if (!hasNext())
			return null;
		T next = this.next.t.get();
		this.next = null;
		return next;
	}
}
